<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>新冠阳康复健日记（一）</title>
    <link href="/2023/01/12/fujian1/"/>
    <url>/2023/01/12/fujian1/</url>
    
    <content type="html"><![CDATA[<p>说来也挺可笑，本来运动在我生活中占的比重是非常大的，结果第一篇关于运动的文章现在才写出来，而且是关于复健的。不过在身体状态逐渐恢复，一切训练正常开展后，关于运动的博客应该会越来越多。</p><h2 id="复健过程">复健过程</h2><p>首先来梳理一下从感染新冠到康复的时间线：12月18日早上起床，感觉嗓子略微疼痛，大量喝水后不见好转。考虑到身边有不少人接二连三地都阳了，我就猜测是不是也中招了。不出所料，当天晚上就开始高烧，体温一度升高到40度。发烧卧床两天后，中间几经波动，逐渐退烧。退烧后体力逐渐恢复，之后便只剩下咳嗽和嗓子疼的症状。嗓子虽然疼，但确实没有常听到的“刀片割”的感觉，只是轻度疼痛，甚至没有普通感冒严重。嗓子疼的症状三四天之后也消失了，咳嗽却依然还在。咳嗽的症状一直不严重，但是很持久，一直持续到了1月6日，才彻底康复。至此，新冠感染后的所有症状都已经痊愈，似乎也没有留下什么后遗症，体力自我感觉也很不错。</p><p>考虑到新冠后的体育锻炼不可冒进，我又间隔了五六天的时间，昨天开始第一次复健。第一次复健的强度和距离都很低，用6分配跑了2000m，试着在低强度的运动中寻找体感，为进一步的恢复做准备。结果非常好，过程中没有任何不适，跑完之后心率恢复也很快。</p><p><imgsrc="https://picbed123.oss-cn-beijing.aliyuncs.com/img/IMG_FE137146845F-1.jpeg" /></p><p>由于昨晚跑的时候体感非常好，今天增加了训练量和强度，用5分配跑了3000m。一方面是尝试一下相对高的配速下身体状态如何，另一方面是看一下有没有网上经常看到的<strong>康复后同配速下心率升高</strong>的现象。</p><p><imgsrc="https://picbed123.oss-cn-beijing.aliyuncs.com/img/IMG_A5A2D58581EB-1.jpeg" /></p><p>体感方面，跑完后的疲惫是一定有的，可能会比感染新冠之前稍微加重一点，但不明显，也属于停训后恢复训练的正常现象。跑完后的身体状态也非常好，没有任何不适，可以快速恢复。</p><p>总体而言，由于复健非常保守，体感还是非常好的。之后会继续循序渐进地增加强度和训练量，把跑步能力恢复到新冠前的最佳状态。</p><h2 id="数据分析">数据分析</h2><h3 id="心率">心率</h3><p>不出所料，心率升高的情况出现了。下面是今天用5分配跑3000m的心率数据，可以看到，平均心率达到了172，到了运动快要结束的时候甚至升高到了180以上。这一心率是高于之前同配速下的数据的。</p><p><imgsrc="https://picbed123.oss-cn-beijing.aliyuncs.com/img/IMG_27506A4A89F4-1.jpeg" /></p><p>如果对比去年11月18号的数据，可以发现，在心率数据几乎完全相同的情况下，今天跑步时的配速下降了38s。根据其他跑者的经验而言，这是停跑后的正常现象，可以在短时间内通过锻炼得到恢复——毕竟即使停跑3周，体能也会有明显下降。而且今天因为有意提升了步频，想要使步频尽可能接近180次每分钟的理想值，对心肺的压力势必会加大。如果考虑到这个因素的话，实际上新冠对心率的升高作用只有每分钟3~4。</p><p><imgsrc="https://picbed123.oss-cn-beijing.aliyuncs.com/img/IMG_EB77680F639C-1.jpeg" /></p><h3 id="跑力指数">跑力指数</h3><p><imgsrc="https://picbed123.oss-cn-beijing.aliyuncs.com/img/IMG_7C905E098405-1.jpeg" /></p><p>经过两天的恢复训练，跑力指数达到了43.4。这一值明显高于20天没有运动后，华为手表自动计算得出的衰减后的跑力值——41.8，这证明身体的状态还是非常不错的。虽然这一数值和12月15日感染新冠前的44.8相比还是有不小的差距，但根据这两天的趋势和体感而言，跑力也可以通过短时间的训练恢复到原先较好的状态。</p><h2 id="预期和目标">预期和目标</h2><p>整体而言，复健算是开了个好头，新冠对身体的影响也没有想象中那么大。希望可以通过2周内的室内跑步机训练恢复到原先的水平。寒假期间，室外空气污染比较严重，温度也比较低，不适合在户外场地开展间歇跑等强度训练。那就希望趁着假期这段时间，借着跑步机方便维持匀速的特点再打一打有氧基础，为开春到学校在有场地的情况下开展包含LSD、乳酸门槛和间歇的全面训练做好准备。</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>运动</tag>
      
      <tag>跑步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-2023春季选课</title>
    <link href="/2023/01/12/xuanke/"/>
    <url>/2023/01/12/xuanke/</url>
    
    <content type="html"><![CDATA[<h2 id="选课">选课</h2><p>今天选课，高数6、物理4+1、化学5、程设3、近代史2、国防2、学术写作2、综工1体育0.5，一共26.5，加上通识是28.5。总体而言课业比上学期要多一些。</p><p><imgsrc="https://picbed123.oss-cn-beijing.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2023-01-12%2016.43.13.png" /></p><p>想来其实这学期要上的课也挺鸡肋的——化学原理去年基本学过一遍了，配套的化学实验去年的上半学期更是完整地做过一遍；程序设计这种课基本也就靠自学了，听课学编程是决不可能有什么好效果的；体育课因为这学期的游泳II考核太难也换成了体适能。高分，但也几乎没什么趣味，估计下学期的锻炼也只能靠平时的跑步和骑行了。有那么些实际意义的课只剩下高数、大物和英语了——英语勉强算一个吧。化学实验要安排到周一的上午1-4节，等效计算下来，一周一共有18节课。还是不少的，至少比上个学期明显地多了。课多了，空余的、自由安排的时间便会减少——这些许会令人感到有些压力。但无论如何，比大二的学长们还是轻松不少，课少，也没他们那么难，这是值得庆幸的。</p><p>选完课，又想到了<em>SurviveSJTUMaual</em>开篇振聋发聩的那几段话，这里再附上来：</p><blockquote><p>各位同学们，在本书的开始，我不得不遗憾地告诉大家一个消息。国内绝大部分大学的本科教学，不是濒临崩溃，而是早已崩溃。在此，我无意争论是否复旦、中科大、或者清华、北大是否比我们崩溃的更少一些——这种争论是没有意义的。我只是看到了无数充满求知欲、激情、与年轻梦想的同学们，将要把自己的四年青春，充满希望与信任地交给大学来塑造。这使我心中非常不安。</p></blockquote><blockquote><p>在当今流水线式的教育体制下，我们就像廉价的零件一样被生产出来。因为数量巨大，没人会对每一个人的教学质量负责。</p></blockquote><blockquote><p>领导不会为你负责。对于一个争做世界一流大学的研究型学校，管好科研，管好实验室才是当务之急。相比之下，本科生教学显得无利可图。教授也不会为你负责。拉到足够的经费发表足够的论文，满足学院要求才是生存大计。要说管学生，也肯定先要管好自己实验室的硕士博士，而非那一百多人大课堂里的某个本科生。就算是科研任务不太重的一些任课教师，他们也不会为你负责——学不懂？那是因为你智力低，要么就是自己底下不用功。为什么跟你一个班上的某某某同学，人家就能懂？诚然，就算是老师上课说孟加拉语，一个班上也非常有可能冒出一两个翻翻书看看图就能学到八九不离十的同学（或者根本就是以前学过）。真正在课堂上口传心授的教学，其质量是不会有人过问的。教学评估会考察实验报告格式是否合格，出勤率是否够，但是绝对不会考察上百人的班上到底有几个听懂了的。</p></blockquote><blockquote><p>试想一下，每个学院每个系有成百上千的学生，每人有着不同的思想、不同的目标、不同的知识背景、不同的接受力，我们怎么可能去指望一个统一的“教学培养计划”强制应用在每个人头上的时候，能够产生效果？好比说食堂师傅炒一大锅菜给上千人吃，我敢说我分到的那盘，不是炒糊就肯定得夹生。</p></blockquote><blockquote><p>所谓“教学培养计划”，其科学性必须经过教育权威的论证。然而现实中塞给我们的推荐课表，却让人失望。且不深究选修课的分类、学分、毕业条件每年一个样，三年大变样，使得不少同学毕业前夕竞相奔走；甚至连两门相依赖课程的教学先后顺序都搞错过，这样的教学培养计划，实在让人难以信任。</p></blockquote><blockquote><p>而对于具体课程，教学大纲的陈旧程度也令人叹为观止。当然，以“教学经验”的名义，十年用同一本教科书是可以理解的。甚至我们可以容忍教学大纲里有一些广受诟病的古典残留物（例如《线性代数》中的Cramer法解方程）。但我们无法容忍对于一门只有几十年历史的新兴学科，我们的教科书竟然可以只涉及到上个世纪八十年代的“新技术”！这样的课程，之所以能够存在并延续下去，从根本上讲是因人设课——开设相应课程是为了不让部分教师下岗。这也无怪国外有华裔学者实在看不下去了，拍案疾呼道：“中国大学，怎么那么盛产‘活化石’！”。</p></blockquote><p>下学期又能从学校的老师那里学到多少有用的知识呢？我不知道，但应该不会太多罢。每个学期似乎都是这样，真正能从老师那里有很大收获的课并不多，但它们却占用了平时时间的大头。这令不只我，甚至学校的大部分学生都十分无奈。今年9月就要参加国赛，还有明年这个时候的美赛，自己还有不少想要学的东西——Python，粤语，还有搁置不少时间的摄影。这样看，似乎终究又还是要靠自己了。希望能顺利完成下学期的学业，完成既定的目标吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>学习</tag>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近期C语言学习记录</title>
    <link href="/2023/01/11/C/"/>
    <url>/2023/01/11/C/</url>
    
    <content type="html"><![CDATA[<h2 id="第一个c语言程序代码加法器">第一个C语言程序代码——加法器</h2><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">float</span> a,b,c;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入第一个数：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%f&quot;</span>,&amp;a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入第二个数：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%f&quot;</span>,&amp;b);<br>    c=a+b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>,c);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自增运算符">自增运算符</h2><p><code>i++</code>和<code>++i</code>都是实现变量i的自增，两者的区别在于<code>i++</code>是先运算，再加<code>1</code>，而<code>++i</code>是先加<code>1</code>，后运算。但是不管是<code>i++</code>还是<code>++i</code>，最后i的值都是相同的。</p><p>举例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   <span class="hljs-type">int</span> c;<br>   <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>   c = a++; <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;先赋值后运算：\n&quot;</span>);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 1 - c 的值是 %d\n&quot;</span>, c );<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 2 - a 的值是 %d\n&quot;</span>, a );<br>   a = <span class="hljs-number">10</span>;<br>   c = a--; <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 3 - c 的值是 %d\n&quot;</span>, c );<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 4 - a 的值是 %d\n&quot;</span>, a );<br> <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;先运算后赋值：\n&quot;</span>);<br>   a = <span class="hljs-number">10</span>;<br>   c = ++a; <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 5 - c 的值是 %d\n&quot;</span>, c );<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 6 - a 的值是 %d\n&quot;</span>, a );<br>   a = <span class="hljs-number">10</span>;<br>   c = --a; <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 7 - c 的值是 %d\n&quot;</span>, c );<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Line 8 - a 的值是 %d\n&quot;</span>, a );<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">先赋值后运算：<br>Line <span class="hljs-number">1</span> - c 的值是 <span class="hljs-number">10</span><br>Line <span class="hljs-number">2</span> - a 的值是 <span class="hljs-number">11</span><br>Line <span class="hljs-number">3</span> - c 的值是 <span class="hljs-number">10</span><br>Line <span class="hljs-number">4</span> - a 的值是 <span class="hljs-number">9</span><br>先运算后赋值：<br>Line <span class="hljs-number">5</span> - c 的值是 <span class="hljs-number">11</span><br>Line <span class="hljs-number">6</span> - a 的值是 <span class="hljs-number">11</span><br>Line <span class="hljs-number">7</span> - c 的值是 <span class="hljs-number">9</span><br>Line <span class="hljs-number">8</span> - a 的值是 <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="指针实现交换函数">指针实现交换函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">exchange</span><span class="hljs-params">(<span class="hljs-type">int</span> *p, <span class="hljs-type">int</span> *q)</span> <br>&#123;<br>   <span class="hljs-type">int</span> a;<br>   a=*p;<br>   *p=*q;<br>   *q=a;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   <span class="hljs-type">int</span> x,y;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入x：&quot;</span>);<br>   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入y：&quot;</span>);<br>   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;y);<br>   exchange(&amp;x,&amp;y);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;交换后，x=%d\n&quot;</span>,x);<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;交换后，y=%d\n&quot;</span>,y);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>学习</tag>
      
      <tag>计算机</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四种常见排序算法的Python实现</title>
    <link href="/2023/01/11/sanzhongpaixu/"/>
    <url>/2023/01/11/sanzhongpaixu/</url>
    
    <content type="html"><![CDATA[<p>今天试着用Python实现了冒泡排序、选择排序、插入排序和快速排序，代码如下：</p><h2 id="冒泡排序">冒泡排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">a=<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你要排序的列表：&quot;</span>))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-keyword">if</span> a[t]&gt;a[t+<span class="hljs-number">1</span>]:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compare_list</span>(<span class="hljs-params">a</span>):<br>    lst=[]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(a)-<span class="hljs-number">1</span>):<br>        lst.append(compare(i))<br>    <span class="hljs-keyword">return</span> lst<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">sum</span>(compare_list(a))&lt;<span class="hljs-built_in">len</span>(a)-<span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(a)-<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> compare(j)==<span class="hljs-number">0</span>:<br>            c=a[j+<span class="hljs-number">1</span>]<br>            a[j+<span class="hljs-number">1</span>]=a[j]<br>            a[j]=c<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure><h2 id="选择排序">选择排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">a=<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你要排序的列表：&quot;</span>))<br>lst=[]<br>ini_length=<span class="hljs-built_in">len</span>(a)<br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(lst)&lt;ini_length:<br>    lst.append(<span class="hljs-built_in">max</span>(a))<br>    a.remove(<span class="hljs-built_in">max</span>(a))<br>lst=lst[::-<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(lst)<br></code></pre></td></tr></table></figure><h2 id="插入排序">插入排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">a=<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你要排序的列表：&quot;</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(a)):<br>    j=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> a[i]&gt;a[j]:<br>        j=j+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        a.insert(j,a[i])<br>        <span class="hljs-keyword">del</span> a[i+<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure><h2 id="快速排序">快速排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">data</span>):      <br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data)&gt;=<span class="hljs-number">2</span>:        <br>        mid=data[<span class="hljs-built_in">len</span>(data)//<span class="hljs-number">2</span>]<br>        left,right=[],[]    <br>        data.remove(mid)     <br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> data:            <br>            <span class="hljs-keyword">if</span> num&gt;=mid:                <br>                right.append(num)            <br>            <span class="hljs-keyword">else</span>:                <br>                left.append(num)        <br>        <span class="hljs-keyword">return</span> quick_sort(left)+[mid]+quick_sort(right)    <br>    <span class="hljs-keyword">else</span>:        <br>        <span class="hljs-keyword">return</span> data<br>a=<span class="hljs-built_in">eval</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你要排序的列表：&quot;</span>))<br><span class="hljs-built_in">print</span>(quick_sort(a))<br></code></pre></td></tr></table></figure><p>这里的快速排序代码使用了分而治之和递归的思想，在定义的函数体中实现了递归，有效简化了代码。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>学习</tag>
      
      <tag>计算机</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对面向对象编程的理解</title>
    <link href="/2023/01/11/mianxiangduixiang/"/>
    <url>/2023/01/11/mianxiangduixiang/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象编程">面向对象编程</h2><p>面向对象编程有三个基本特点：</p><p><strong>封装</strong>封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p><p><strong>继承</strong>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来类的情况下对这些功能进行扩展。通过继承创建的新类称为「子类」或「派生类」，被继承的类称为「基类」、「父类」或「超类」。要实现继承，可以通过 <strong>继承和组合</strong> 来实现。</p><p><strong>多态性</strong>多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单说就是一句话：允许将子类类型的指针赋值给父类类型的指针。</p><p>简而言之，<strong>面向对象的编程方式使得每一个类都只做一件事</strong>。<strong>面向过程会让一个类越来越全能，就像一个管家一样做了所有的事</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>学习</tag>
      
      <tag>计算机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Eason新歌盲婚哑嫁</title>
    <link href="/2023/01/10/manghunyajia/"/>
    <url>/2023/01/10/manghunyajia/</url>
    
    <content type="html"><![CDATA[<h2 id="盲婚哑嫁">盲婚哑嫁</h2><p>昨晚9.00pm在Youtube上准点观看了Eason的新歌《盲婚哑嫁》mv放松。说实话，有点小失望。</p><span id="more"></span><p>mv还是很不错的，从演绎和拍摄角度而言都很好。但曲风、旋律和歌词就有点显然差了一个档次。旋律一开始就很高亢，或者这个词不很合适，换个说法——比较轻快。个人感觉这和整首歌的主题还有mv的画面并不太搭配。盲婚哑嫁本是一个沉重的话题，它和旋律以及编曲结合起来总感觉很违和。副歌旋律差强人意，但不太抓耳。</p><p>至于歌词，最基本的协音肯定没有问题，但能看出很多韵押得比较勉强，比如“她”、“码”等。一些用词也比较奇怪，比如“根生已忘记花”，有可以炫技的嫌疑。也许是林夕和Wyman的词听得多了，一般的词水平上总感觉有欠缺。总体而言，这首歌听感比之前的《人啊人》好一些，但远没达到理想水平。</p><p>Eason的嗓音越来越醇厚，可惜制作人都不是老搭档了，比如EricKwok、ChristopherChak、陈辉阳、Wyman、林夕。歌曲本应随着作品数量和时间阅历越来越精彩越有味道的，但由于很多人都没再合作，歌曲质量可以说出现了一定的退步。</p><p>真的不想Eason在唱功不退反进的情况下听到这些质量不太如意的歌，希望之后的歌曲能有所改进吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 3.8中的新特性——海象运算符</title>
    <link href="/2023/01/09/walrus/"/>
    <url>/2023/01/09/walrus/</url>
    
    <content type="html"><![CDATA[<h2 id="海象运算符">海象运算符</h2><p>海象运算符的英文原名叫 Assignment Expresions，即<strong>赋值表达式</strong>。是Python 3.8新增的语法 :=，在 PEP 572中提出。它的作用是<strong>在表达式内部为变量赋值</strong></p><span id="more"></span><h2 id="实例">实例</h2><p>一般写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">15</span><br><span class="hljs-keyword">if</span> a &gt; <span class="hljs-number">10</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello, walrus operator!&#x27;</span>)<br></code></pre></td></tr></table></figure><p>改进写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> a := <span class="hljs-number">15</span> &gt; <span class="hljs-number">10</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello, walrus operator!&#x27;</span>)<br></code></pre></td></tr></table></figure><p>可以在<code>Expression</code>的内部直接为变量赋值，可以简化代码和提升运算效率。</p><h2 id="用于列表推导式">用于列表推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">16</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;运行了函数f(x)1次。&#x27;</span>)<br>    <span class="hljs-keyword">return</span> x ** <span class="hljs-number">0.5</span><br><span class="hljs-built_in">print</span>([f(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums <span class="hljs-keyword">if</span> f(i) &gt; <span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">运行了函数f(x)<span class="hljs-number">1</span>次。<br>运行了函数f(x)<span class="hljs-number">1</span>次。<br>运行了函数f(x)<span class="hljs-number">1</span>次。<br>运行了函数f(x)<span class="hljs-number">1</span>次。<br>运行了函数f(x)<span class="hljs-number">1</span>次。<br>运行了函数f(x)<span class="hljs-number">1</span>次。<br>运行了函数f(x)<span class="hljs-number">1</span>次。<br>[<span class="hljs-number">6.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">8.0</span>]<br></code></pre></td></tr></table></figure><p>一共就 <code>4</code> 个数字，但是函数被执行了 <code>7</code>次。这是因为有三个数字满足列表推导式的条件，需要再额外计算<code>3</code>次。<strong>当程序数据巨大的时候，这将浪费大量性能。</strong></p><p>改进：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">16</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;运行了函数f(x)1次。&#x27;</span>)<br>    <span class="hljs-keyword">return</span> x ** <span class="hljs-number">0.5</span><br><span class="hljs-built_in">print</span>([n <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums <span class="hljs-keyword">if</span> (n := f(i)) &gt; <span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">运行了函数f(x)<span class="hljs-number">1</span>次。<br>运行了函数f(x)<span class="hljs-number">1</span>次。<br>运行了函数f(x)<span class="hljs-number">1</span>次。<br>运行了函数f(x)<span class="hljs-number">1</span>次。<br>[<span class="hljs-number">6.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">8.0</span>]<br></code></pre></td></tr></table></figure><p>函数只执行了 <code>4</code> 次，函数执行结果被 <code>n</code>储存，不需要额外计算。性能优于不使用 <code>:=</code> 的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>学习</tag>
      
      <tag>计算机</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>惯性定理的几何意义</title>
    <link href="/2023/01/09/quadratic/"/>
    <url>/2023/01/09/quadratic/</url>
    
    <content type="html"><![CDATA[<h2 id="惯性定理">惯性定理</h2><h3 id="引子">引子</h3><p>先看一道题：</p><span id="more"></span><div class="note note-success">            <p>二次型<spanclass="math inline">\(f(x_{1},x_{2},x_{3})=(x_{1}+x_{2})^2+(x_{2}+x_{3})^2-(x_{3}-x_{1})^2\)</span>的正惯性指数和负惯性指数是___________.</p>          </div><p>看到题，一般而言会立刻想到惯性定理：不管选取怎样的可逆线性变换使二次型化为仅含有平方项的标准形，其中正平方项和负平方项的个数都是由所给二次型唯一确定的。于是观察题目中二次型的结构，三个括号的平方，系数两正一负，填入答案<spanclass="math inline">\(2,1\)</span>。这时，所用的线性变换即为 <spanclass="math display">\[y_{1}=x_{1}+x_{2},~y_{2}=x_{2}+x_{3},~y_{3}=x_{3}-x_{1}\]</span></p><p>这样做对吗？错的。原因在于，惯性定理中所用到的线性变换必须是可逆线性变换。回看刚才使用的线性变换，<span class="math display">\[\left[\begin{aligned}y_{1}\\y_{2}\\y_{3}\end{aligned}\right]=\left[\begin{array}{lll}~1 &amp; 1 &amp; 0 \\~0 &amp; 1 &amp; 1 \\-1 &amp; 0 &amp; 1\end{array}\right]\left[\begin{aligned}x_{1}\\x_{2}\\x_{3}\end{aligned}\right]\]</span> 由于 <span class="math display">\[\text{r}(\left[\begin{array}{lll}~1 &amp; 1 &amp; 0 \\~0 &amp; 1 &amp; 1 \\-1 &amp; 0 &amp; 1\end{array}\right])=2\]</span>这显然不是一个可逆线性变换，不符合惯性定理的使用条件，不能使用定理得到结论。事实上，这道题目正确的做法应该是：</p><p>将二次型展开化简，得到： <span class="math display">\[f(x_{1},x_{2},x_{3})=2x_{2}^2+2x_{1}x_{2}+2x_{2}x_{3}+2x_{1}x_{3}\]</span> 则二次型矩阵 <span class="math display">\[A=\left[\begin{array}{lll}0 &amp; 1 &amp; 1 \\1 &amp; 2 &amp; 1 \\1 &amp; 1 &amp; 0\end{array}\right]\]</span> 根据公式<span class="math inline">\(|\lambdaE-A|=0\)</span>，可以得到特征值分别为<spanclass="math inline">\(0,-1,3\)</span>，因此正、负惯性指数都为<spanclass="math inline">\(1\)</span>。</p><p>惯性定理从几何层面上反映了：一个二次曲面经过可逆的线性变换后，其拓扑性质应该保持不变（也就是正负惯性指数不变）。如果使用了退化的线性变换，高维的几何图形便会变为低维图形，拓扑性质改变，自然也就不能保证“正负惯性指数相同”了。</p><h3 id="从几何角度理解惯性定理">从几何角度理解惯性定理</h3><p>我们来考虑一个简单的例子：二次型<spanclass="math inline">\(x_{1}^2-4x_{1}x_{2}+x_{2}^2\)</span>在<spanclass="math inline">\(1\)</span>的等值线，也即<spanclass="math inline">\(x_{1}^2-4x_{1}x_{2}+x_{2}^2=1\)</span>。</p><p>通过绘图，我们可以得出，这一等值线的形态为斜置的双曲线。</p><p><imgsrc="https://picbed123.oss-cn-beijing.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2023-01-09%2011.48.26.png" /></p><p>这里，二次型的矩阵为 <span class="math display">\[A=\left[\begin{array}{lll}~1 &amp; -2 \\-2 &amp; ~1\end{array}\right]\]</span> 通过正交变换法，我们容易找到正交矩阵 <spanclass="math display">\[C=\left[\begin{array}{lll}\dfrac{1}{\sqrt{2}} &amp; -\dfrac{1}{\sqrt{2}} \\\dfrac{1}{\sqrt{2}} &amp; ~~\dfrac{1}{\sqrt{2}}\end{array}\right]\]</span> 使得 <span class="math display">\[C^TAC=S=\left[\begin{array}{lll}-1 &amp; 0 \\~~0 &amp; 3\end{array}\right]\]</span> 而且<span class="math inline">\(C\)</span>是可逆变换。</p><p>变换后的标准形是<spanclass="math inline">\(-y_{1}^2+3y_{2}^2=1\)</span>。由标准形的形式可以看出，变换后的二次型在<spanclass="math inline">\(1\)</span>处的等值线仍然表示双曲线。这是因为，二维平面上的线性变换的本质实际上是选取了与原先基底不同的另一组线性无关的基底，并由基底的变换对原先的图形进行了变换。从动态的角度上讲，是在保持大致形状不变的情况下对原先的图形进行了伸缩和扭转。那么自然，原来是双曲线，经过伸缩扭转后一定还是双曲线，不会变成椭圆或者抛物线。进而，正惯性指数和负惯性指数也是不会改变的。它们一旦改变，对应图形就会变成椭圆或者抛物线，这显然与刚才的推导不符。惯性定理从几何上讲是一定成立的。</p><p><imgsrc="https://picbed123.oss-cn-beijing.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2023-01-09%2012.10.33.png" /></p><p>要注意，上述过程成立的前提是，我们选取的一组新基底中两个向量是线性无关的，也就是惯性定理中提到的<strong>可逆线性变换</strong>，或者说<strong>非退化线性变换</strong>。从几何上讲，这一条件保证了原有的坐标平面以及图形不会被“压平”到一条直线上。这也很好理解。由于新的基底中两个向量线性无关，也就是它们不共线，那么原先在坐标平面上两个不共线的向量经过变换后依然不会共线。那现在我们来看看，如果舍弃掉这一条件又会如何呢？我们选择线性变换<span class="math display">\[D=\left[\begin{array}{lll}~1 &amp; 0 \\-1 &amp; 0\end{array}\right]\]</span> 在这一线性变换的作用下， <span class="math display">\[D^TAD=\left[\begin{array}{lll}2 &amp; 0 \\0 &amp; 0\end{array}\right]\]</span> 二次型变成了 <span class="math display">\[2x_{1}^2=1\]</span>几何上表示什么呢？一对直线。原先的双曲线由于新基底中包含了<spanclass="math inline">\((0,0)^T\)</span>退化成了直线。那么我们能说，这里的正惯性指数是<spanclass="math inline">\(1\)</span>，负惯性指数是<spanclass="math inline">\(0\)</span>吗？不能了。现在的正负惯性指数已经不能代表图形的拓扑性质了，因而也就不再具有不变形。我们甚至选择不同的退化线性变换<spanclass="math inline">\(D\)</span>，还可以得到不同的结果，比如 <spanclass="math display">\[D&#39;=\left[\begin{array}{lll}1 &amp; 0 \\1 &amp; 0\end{array}\right]\]</span> 可以得到 <span class="math display">\[D&#39;^TAD&#39;=\left[\begin{array}{lll}-2 &amp; 0 \\0 &amp; 0\end{array}\right]\]</span> 显然我们也不能说，这里的正惯性指数是<spanclass="math inline">\(0\)</span>，负惯性指数是<spanclass="math inline">\(1\)</span>。使用了一个不可逆的线性变换，得到的二次型就退化了，失真了，没有意义了。</p><p>这是应用惯性定理时一个特别需要注意的问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相似矩阵知识点</title>
    <link href="/2023/01/08/similar-matrix/"/>
    <url>/2023/01/08/similar-matrix/</url>
    
    <content type="html"><![CDATA[<h2 id="二级结论">二级结论</h2><ol type="1"><li>与对角矩阵相似的只有对角矩阵</li><li>相似矩阵的迹相等，即<spanclass="math inline">\(\text{tr}(A)=\text{tr}(B)\)</span></li><li>相似矩阵的秩相等</li><li>相似矩阵有相同的特征值</li><li>与实对称矩阵相似的矩阵必可以相似对角化</li><li>矩阵可以相似对角化只有两种情况：要么有<spanclass="math inline">\(n\)</span>的不同的特征值，要么所有的<spanclass="math inline">\(k\)</span>重特征值的几何重数也为<spanclass="math inline">\(k\)</span></li></ol><span id="more"></span><h2 id="相似矩阵特征向量的关系">相似矩阵特征向量的关系</h2><p>若<span class="math inline">\(P^{-1}AP=B\)</span>，<spanclass="math inline">\(B\)</span>有特征向量<spanclass="math inline">\(\beta\)</span>，则有如下推论：</p><p>因<span class="math inline">\(P^{-1}AP=B\)</span>，<spanclass="math inline">\(B=\lambda\beta\)</span>，则 <spanclass="math display">\[A=PBP^{-1}\]</span> 故而 <span class="math display">\[AP\beta=PBP^{-1}P\beta=PBP\beta=P\lambda\beta\]</span> <spanclass="math inline">\(\lambda\)</span>作为数可以提到前面，则 <spanclass="math display">\[AP\beta=\lambda P\beta\]</span></p><p>由此可以得到，<span class="math inline">\(A\)</span>有特征向量<spanclass="math inline">\(P\beta\)</span>。</p><h2 id="先拆后合求特征值">“先拆后合”求特征值</h2><p>求矩阵<span class="math inline">\(A\)</span>的特征值可以把<spanclass="math inline">\(A\)</span>拆成一个简单矩阵<spanclass="math inline">\(B\)</span>和若干倍的<spanclass="math inline">\(E\)</span>的和，先求出<spanclass="math inline">\(B\)</span>的特征值，再根据特征值的性质求出<spanclass="math inline">\(A\)</span>的特征值。具体而言，可以进行如下操作：</p><p><strong>例：求矩阵<spanclass="math inline">\(A=\left[\begin{array}{ccccc}a &amp; 1 &amp; 1&amp; \cdots &amp; 1 \\ 1 &amp; a &amp; 1 &amp; \cdots &amp; 1 \\ 1&amp; 1 &amp; a &amp; \cdots &amp; 1 \\ \vdots &amp; \vdots &amp; \vdots&amp; &amp; \vdots \\ 1 &amp; 1 &amp; 1 &amp; \cdots &amp;a\end{array}\right]\)</span>的特征值</strong></p><p>解：由题目知， <span class="math display">\[\begin{aligned} \boldsymbol{A} &amp; =\left[\begin{array}{lllll}a-1&amp; &amp; &amp; &amp; \\ &amp; a-1 &amp; &amp; &amp; \\ &amp; &amp;a-1 &amp; &amp; \\ &amp; &amp; &amp; \ddots &amp; \\ &amp; &amp; &amp;a-1\end{array}\right]+\left[\begin{array}{ccccc}1 &amp; 1 &amp; 1 &amp;\cdots &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 \\ 1 &amp; 1&amp; 1 &amp; \cdots &amp; 1 \\ \vdots &amp; \vdots &amp; \vdots &amp;&amp; \vdots \\ 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1\end{array}\right]\\ &amp; =(a-1) \boldsymbol{E}+\boldsymbol{B},\end{aligned}\]</span></p><p>而矩阵<span class="math inline">\(\boldsymbol{B}\)</span>的秩为<spanclass="math inline">\(1\)</span>，有 <span class="math display">\[|\lambda \boldsymbol{E}-\boldsymbol{B}|=\lambda^n-n\lambda^{n-1}\]</span> 得到矩阵<spanclass="math inline">\(\boldsymbol{B}\)</span>的特征值为<spanclass="math inline">\(n,0,0,...,0\)</span>，因此<spanclass="math inline">\(\boldsymbol{A}\)</span>的特征值为<spanclass="math inline">\(n+a-1,a-1,a-1,...,a-1\)</span>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>也许不曾缺少善意</title>
    <link href="/2023/01/07/jingxiuqiancheng/"/>
    <url>/2023/01/07/jingxiuqiancheng/</url>
    
    <content type="html"><![CDATA[<h2 id="也许不曾缺少善意">也许不曾缺少善意</h2><p>自从目睹“虎子事件”，十几万粉丝被愚弄，虎子收割了善意和同情后以“死亡”淡出了观众视野后，我便对身患疾病（或真或假），在B站上拍摄视频“募捐”的人有所抵触。虽然不能判断真假，但我也不再会随意地向一个陌生人释放善意了。即使没有什么物质上的付出，释放善意后却发现被欺骗的感觉总归是不好受的。</p><p>然而，这两天总看到B站主页推送UP主“<strong>景秀前程老周抗癌中</strong>”的视频。我一如既往地划走，继续寻找我感兴趣的视频。可连续推送了几天之后，我发现他的视频有分享阳过，阳康经历的，有“今天来给大家做道菜”，也有翻唱歌曲的，似乎不像是一个身患疾病的老人通常会拍视频发布的内容。</p><p><imgsrc="https://picbed123.oss-cn-beijing.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2023-01-07%2019.16.19.png" /></p><p>单纯出于好奇，点进他的几期做菜视频。虽然这些菜式都比较家常，但每期视频里他都会细致地介绍食材、做法，以及最终的成品展示。他的设备并不专业，拍摄手法也很直白，但总能给人一种“他真的有在认真教大家做菜”的感觉。听着他一边做菜一边讲解，有时还在最后亲自品尝，莫名地有一种亲切的感受。他拍的那期“阳春面”的视频令人印象尤其深刻。不加修饰的家常做法、和最后那句带着笑容的“小时候能够吃到这样的一碗面，那就太开心了”，实在令人感到温暖。不知怎么地，他就像一个邻家的富有生活情趣的老人，认真地制作美食、认真地生活。“他是不是真的得病了？”“他是不是在骗取同情？”当看他的视频的时候，这种问题甚至很难问出口。学一道菜，听一首歌，这便足够。再留下两个硬币，是更好的。也许只有亲自看完他的视频之后才能有体会，但无论如何，他跟以往那些B站上的“抗癌”视频不同，每次看完总能给人积极向上的感受。</p><p>评论区中留言的朋友们大抵看完后也都有相似的心境吧。乐观积极的感染力是一种广谱的感染力，它能在乌烟瘴气、充斥着抽象和反智的网络空间中开辟出一片净土，唤醒众人最本能的恻隐之心。我们绝大多数人在生活的长征路上都各有各的苦难，刻意的卖惨在当今只会招来怀疑和谩骂，因为它不能给我们的生活带来正能量。我们每天接收到的负面信息已经接近饱和了，没有人会像徒增悲悯和哀伤。<strong>景秀前程老周抗癌中</strong>的视频告诉我们，“抗癌”视频也可以不以乞怜的形式拍摄。在困境中保持对生活的热爱，把这份热爱传递给他人，这样的人理应受到最多的帮助、最大的支持。</p><p><imgsrc="https://picbed123.oss-cn-beijing.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2023-01-07%2022.22.18.png" /></p><p>祝早日康复。</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由一道考研线性代数题目引发的思考</title>
    <link href="/2023/01/06/Jordan/"/>
    <url>/2023/01/06/Jordan/</url>
    
    <content type="html"><![CDATA[<h2id="由一道考研线性代数题目引发的思考">由一道考研线性代数题目引发的思考</h2><h3 id="母题">母题</h3><p>上午复习线性代数的时候做到了一道很有意思的题目：</p><span id="more"></span><div class="note note-success">            <p>设<span class="math inline">\(\boldsymbol{A}\)</span>是<spanclass="math inline">\(n\)</span>阶矩阵, <spanclass="math inline">\(\boldsymbol{\alpha}_{1},\boldsymbol{\alpha}_{2},\boldsymbol{\alpha}_{3}\)</span>是<spanclass="math inline">\(n\)</span>维列向量，若<spanclass="math inline">\(\boldsymbol{A\alpha}_{1}=\boldsymbol{\alpha}_{1}\neq\mathbf{0},\boldsymbol{A}\boldsymbol{\alpha}_2=\boldsymbol{\alpha}_1+\boldsymbol{\alpha}_2,\boldsymbol{A}\boldsymbol{\alpha}_3=\boldsymbol{\alpha}_2+\boldsymbol{\alpha}_3\)</span>，证明向量组<spanclass="math inline">\(\boldsymbol{\alpha}_{1},\boldsymbol{\alpha}_{2},\boldsymbol{\alpha}_{3}\)</span>线性无关.</p>          </div><p>一开始看到这道题，很自然地想到把题目条件写成矩阵形式进行处理。于是得到：</p><p><spanclass="math display">\[\boldsymbol{A}[\boldsymbol{\alpha}_{1}~~\boldsymbol{\alpha}_{2}~~\boldsymbol{\alpha}_{3}]=[\boldsymbol{\alpha}_{1}~~\boldsymbol{\alpha}_{2}~~\boldsymbol{\alpha}_{3}]\left[\begin{array}{lll}1 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 1 \\0 &amp; 0 &amp; 1\end{array}\right]\]</span></p><p>在这里，<spanclass="math inline">\(\boldsymbol{A\alpha}_{1}\neq\mathbf{0}\)</span>，因此<spanclass="math inline">\(\boldsymbol{A}\neq\boldsymbol{0}\)</span>。但再往下，似乎难以做进一步的处理了。</p><p>题目需要证明<spanclass="math inline">\(\boldsymbol{\alpha}_{1},\boldsymbol{\alpha}_{2},\boldsymbol{\alpha}_{3}\)</span>线性无关，如果记<spanclass="math inline">\(\boldsymbol{P}=[\boldsymbol{\alpha}_{1}~~\boldsymbol{\alpha}_{2}~~\boldsymbol{\alpha}_{3}]\)</span>，那就要说明<spanclass="math inline">\(\text{rank}(\boldsymbol{P})=3\)</span>，或者<spanclass="math inline">\(\det(\boldsymbol{P})\neq0\)</span>。</p><p>但在不知道<spanclass="math inline">\(\boldsymbol{A}\)</span>的具体信息的时候，无论是通过左/右乘矩阵，还是对两边取行列式，似乎都很难得到想要的结论。题目也没有多出的条件，通过矩阵变换证明的思路似乎难以走通了。</p><p>翻看标准答案，深感巧妙。答案的思路是这样的：由于<spanclass="math inline">\(\boldsymbol{A\alpha}_{1}=\boldsymbol{\alpha}_{1}\neq\mathbf{0},\boldsymbol{A}\boldsymbol{\alpha}_2=\boldsymbol{\alpha}_1+\boldsymbol{\alpha}_2,\boldsymbol{A}\boldsymbol{\alpha}_3=\boldsymbol{\alpha}_2+\boldsymbol{\alpha}_3\)</span>，则</p><p><spanclass="math display">\[(\boldsymbol{A}-\boldsymbol{E})\boldsymbol{\alpha}_{1}=\boldsymbol{0}\]</span></p><p><spanclass="math display">\[(\boldsymbol{A}-\boldsymbol{E})\boldsymbol{\alpha}_{2}=\boldsymbol{\alpha}_{1}\]</span></p><p><spanclass="math display">\[(\boldsymbol{A}-\boldsymbol{E})\boldsymbol{\alpha}_{3}=\boldsymbol{\alpha}_{2}\]</span></p><p>假设<spanclass="math inline">\(\boldsymbol{\alpha}_{1},\boldsymbol{\alpha}_{2},\boldsymbol{\alpha}_{3}\)</span>线性相关，则存在$k_{1},k_{2},k_{3}~~$</p><p><spanclass="math display">\[\begin{equation}k_{1}\boldsymbol{\alpha}_{1}+k_{2}\boldsymbol{\alpha}_{2}+k_{3}\boldsymbol{\alpha}_{3}=0\end{equation}\]</span></p><p>且<span class="math inline">\(k_{1},k_{2},k_{3}\)</span>不全为<spanclass="math inline">\(0\)</span>。</p><p>用<spanclass="math inline">\((\boldsymbol{A}-\boldsymbol{E})\)</span>左乘<spanclass="math inline">\((1)\)</span>式两侧，得到</p><p><spanclass="math display">\[k_{2}\boldsymbol{\alpha}_{1}+k_{3}\boldsymbol{\alpha}_{2}=0\]</span></p><p>再用<spanclass="math inline">\((\boldsymbol{A}-\boldsymbol{E})\)</span>左乘上式两侧，得到</p><p><spanclass="math display">\[k_{3}\boldsymbol{\alpha}_{1}=0\]</span></p><p>又因为<spanclass="math inline">\(\boldsymbol{\alpha}_{1}\neq\mathbf{0}\)</span>，因此<spanclass="math inline">\(k_{3}=0\)</span>。故进一步得到<spanclass="math inline">\(k_{2}\boldsymbol{\alpha}_{1}=0\)</span>，<spanclass="math inline">\(k_{2}=0\)</span>。同理，再次代入，得到<spanclass="math inline">\(k_{1}=0\)</span>。这与<spanclass="math inline">\(k_{1},k_{2},k_{3}\)</span>不全为<spanclass="math inline">\(0\)</span>是矛盾的，因此向量组<spanclass="math inline">\(\boldsymbol{\alpha}_{1},\boldsymbol{\alpha}_{2},\boldsymbol{\alpha}_{3}\)</span>线性无关。答案巧妙地运用了<spanclass="math inline">\(\boldsymbol{\alpha}_{1}\)</span>是<spanclass="math inline">\(\boldsymbol{A}\)</span>的特征向量这一条件，把待证式不断简化，简化到只含有一个向量，便可以进行处理。</p><p>做到这里，这道题的解答已经完成了。但这类题的一般规律是什么呢？具体而言，如果非零向量<spanclass="math inline">\(\boldsymbol{\alpha}_{1},\boldsymbol{\alpha}_{2},\boldsymbol{\alpha}_{3}\)</span>满足<spanclass="math inline">\(\boldsymbol{A}[\boldsymbol{\alpha}_{1}~~\boldsymbol{\alpha}_{2}~~\boldsymbol{\alpha}_{3}]=[\boldsymbol{\alpha}_{1}~~\boldsymbol{\alpha}_{2}~~\boldsymbol{\alpha}_{3}]\boldsymbol{P}\)</span>，那么当<spanclass="math inline">\(\boldsymbol{P}\)</span>满足什么样的条件时，才能证明<spanclass="math inline">\(\boldsymbol{\alpha}_{1},\boldsymbol{\alpha}_{2},\boldsymbol{\alpha}_{3}\)</span>线性无关呢？</p><p>带着这个问题，我尝试了数种不同的<spanclass="math inline">\(\boldsymbol{P}\)</span>，发现下面这些<spanclass="math inline">\(\boldsymbol{P}\)</span>的取法都可以最终得到线性无关的结论：</p><p><span class="math display">\[\boldsymbol{P}=\left[\begin{array}{lll}-1 &amp; 0 &amp; 0 \\~~0 &amp; 1 &amp; 1 \\~~0 &amp; 0 &amp; 1\end{array}\right]\]</span></p><p><span class="math display">\[\boldsymbol{P}=\left[\begin{array}{lll}2 &amp; ~~0 &amp; ~~0 \\0 &amp; -1 &amp; ~~1 \\0 &amp; ~~0 &amp; -1\end{array}\right]\]</span></p><p>这时，规律仍然不太明显。但回看原题的条件：“<spanclass="math inline">\(\boldsymbol{A\alpha}_{1}=\boldsymbol{\alpha}_{1},\boldsymbol{A}\boldsymbol{\alpha}_2=\boldsymbol{\alpha}_1+\boldsymbol{\alpha}_2\)</span>”，似乎与特征值有一些关联。再结合已经得到的符合要求的<spanclass="math inline">\(\boldsymbol{P}\)</span>的样子，很自然地，我们可以联想到<spanclass="math inline">\(\text{Jordan}\)</span>标准型。下面，我们尝试从<spanclass="math inline">\(\text{Jordan}\)</span>标准型出发，试着对母题的出题背景进行分析</p><h3 id="jordan标准型">Jordan标准型</h3><p><spanclass="math inline">\(\text{Jordan}\)</span>标准型是一个矩阵<spanclass="math inline">\(\boldsymbol{J}\)</span>，它除了主对角线和主对角线上方元素之外，其余都是0，且主对角线上方的对角线数若不为<spanclass="math inline">\(0\)</span>则只能为<spanclass="math inline">\(1\)</span>。对角矩阵是一种特殊的<spanclass="math inline">\(\text{Jordan}\)</span>标准型。</p><p><spanclass="math inline">\(\text{Jordan}\)</span>标准型的意义类似于对角矩阵，它代表了任意一个方阵最多可以被简化到的程度。然而，不是所有矩阵都可以被化成对角矩阵，只有那些有<spanclass="math inline">\(n\)</span>个线性无关的特征向量的矩阵可以被对角化，但所有的<spanclass="math inline">\(n\)</span>阶复方阵都有对应的<spanclass="math inline">\(\text{Jordan}\)</span>标准型，也就是说对于任意矩阵<spanclass="math inline">\(\boldsymbol{A}\)</span>，都应该存在可逆矩阵<spanclass="math inline">\(\boldsymbol{P}\)</span>，使得</p><p><spanclass="math display">\[\boldsymbol{P}^{-1}\boldsymbol{AP}=\boldsymbol{J}\]</span></p><p>因此，<spanclass="math inline">\(\text{Jordan}\)</span>标准型可以被视作一种广义的对角矩阵。</p><p>一个<spanclass="math inline">\(\text{Jordan}\)</span>标准型由若干个对角线上排列的<spanclass="math inline">\(\text{Jordan}\)</span>块组成。一个阶数为<spanclass="math inline">\(n_{i}\)</span>的<spanclass="math inline">\(\text{Jordan}\)</span>块定义如下：</p><p><spanclass="math display">\[\boldsymbol{J}_{n_i}(\lambda)=\left(\begin{array}{ccccc}\lambda &amp; 1 &amp; &amp; &amp; 0 \\&amp; \lambda &amp; 1 &amp; &amp; \\&amp; &amp; \ddots &amp; &amp; \\&amp; &amp; &amp; \lambda &amp; 1 \\0 &amp; &amp; &amp; &amp; \lambda\end{array}\right)\]</span></p><p>因此</p><p><span class="math display">\[\boldsymbol{J}=\left(\begin{array}{ccc}J_{n_1}\left(\lambda_1\right) &amp; &amp; 0 \\&amp; \ddots &amp; \\0 &amp; &amp; J_{n_k}\left(\lambda_m\right)\end{array}\right)\]</span></p><p>通过证明，我们能得到如下结论：</p><ol type="1"><li><strong>是否可对角化：</strong>如果一个矩阵的<spanclass="math inline">\(\text{Jordan}\)</span>标准形是对角阵，那么这个矩阵可对角化。</li><li><strong>本征值的代数重数与几何重数：</strong>本征值<spanclass="math inline">\(\lambda_{i}\)</span>在<spanclass="math inline">\(\text{Jordan}\)</span>矩阵对角线上出现的总次数为<spanclass="math inline">\(d_{i}\)</span>（即<spanclass="math inline">\(J(\lambda_{i})\)</span>的阶数为<spanclass="math inline">\(d_{i}\)</span>），则<spanclass="math inline">\(\lambda{i}\)</span>的代数重数为<spanclass="math inline">\(d_{i}\)</span>。本征值<spanclass="math inline">\(\lambda_{i}\)</span>在<spanclass="math inline">\(\text{Jordan}\)</span>矩阵的<spanclass="math inline">\(g_{i}\)</span>个<spanclass="math inline">\(\text{Jordan}\)</span>块中出现过，则<spanclass="math inline">\(\lambda_{i}\)</span>的几何重数为<spanclass="math inline">\(g_{i}\)</span>。</li></ol><p>由以上知识，可以得到三阶方阵的四种<spanclass="math inline">\(\text{Jordan}\)</span>标准型形式：</p><h4 id="第一种">第一种</h4><p><span class="math inline">\(\begin{aligned} &amp; gm\left(\lambda_1\right)=1, g m\left(\lambda_2\right)=1,\operatorname{gm}\left(\lambda_3\right)=1 \\ &amp;\operatorname{am}\left(\lambda_1\right)=1,\operatorname{am}\left(\lambda_2\right)=1,\operatorname{am}\left(\lambda_3\right)=1 \end{aligned}\)</span></p><p><span class="math display">\[\left(\begin{array}{ccc}\lambda_1 &amp; 0 &amp; 0 \\0 &amp; \lambda_2 &amp; 0 \\0 &amp; 0 &amp; \lambda_3\end{array}\right)\]</span></p><h4 id="第二种">第二种</h4><p><span class="math inline">\(\begin{aligned} &amp; gm\left(\lambda_1\right)=1, g m\left(\lambda_2\right)=2, \\ &amp;\operatorname{am}\left(\lambda_1\right)=1,\operatorname{am}\left(\lambda_2\right)=2, \end{aligned}\)</span></p><p><span class="math display">\[\left(\begin{array}{ccc}\lambda_1 &amp; 0 &amp; 0 \\0 &amp; \lambda_2 &amp; 0 \\0 &amp; 0 &amp; \lambda_2\end{array}\right)\]</span></p><h4 id="第三种">第三种</h4><p><span class="math inline">\(\begin{aligned} &amp; gm\left(\lambda_1\right)=1, g m\left(\lambda_2\right)=1, \\ &amp;\operatorname{am}\left(\lambda_1\right)=1,\operatorname{am}\left(\lambda_2\right)=2, \end{aligned}\)</span></p><p><span class="math display">\[\left(\begin{array}{ccc}\lambda_1 &amp; 0 &amp; 0 \\0 &amp; \lambda_2 &amp; 1 \\0 &amp; 0 &amp; \lambda_2\end{array}\right)\]</span></p><h4 id="第四种">第四种</h4><p><span class="math inline">\(\begin{aligned} &amp; gm\left(\lambda_1\right)=1 \\ &amp;\operatorname{am}\left(\lambda_1\right)=3 \end{aligned}\)</span></p><p><span class="math display">\[\left(\begin{array}{ccc}\lambda_1 &amp;1 &amp; 0 \\ 0 &amp; \lambda_1 &amp; 1 \\ 0 &amp; 0 &amp;\lambda_1\end{array}\right)\]</span></p><p>刚才已经提到，所有的<spanclass="math inline">\(n\)</span>阶复方阵都有对应的<spanclass="math inline">\(\text{Jordan}\)</span>​标准型，对于任意矩阵<spanclass="math inline">\(\boldsymbol{A}\)</span>，都应该存在可逆矩阵<spanclass="math inline">\(\boldsymbol{P}\)</span>，使得</p><p><spanclass="math display">\[\boldsymbol{P}^{-1}\boldsymbol{AP}=\boldsymbol{J}\]</span></p><p>也即</p><p><spanclass="math display">\[\boldsymbol{AP}=\boldsymbol{PJ}\]</span></p><p>这一形式与原题中的条件十分已经十分相像了呢？事实上可以发现，母题中所给出的矩阵<spanclass="math inline">\(\left[\begin{array}{lll} 1 &amp; 1 &amp; 0 \\ 0&amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 1\end{array}\right]\)</span>与我们找到的符合要求的矩阵恰好符合<spanclass="math inline">\(\text{Jordan}\)</span>标准型的形式。</p><p>与矩阵的相似对角化类似，如果我们把这里的<spanclass="math inline">\(\boldsymbol{P}\)</span>按列分块，可以得到，<spanclass="math inline">\(\boldsymbol{P}\)</span>的列向量组恰好是<spanclass="math inline">\(\boldsymbol{A}\)</span>的<spanclass="math inline">\(n\)</span>个的广义特征向量（即满足<spanclass="math inline">\((\boldsymbol{A}-\lambda\boldsymbol{E})^{m}\boldsymbol{\alpha}=\boldsymbol{0}\)</span>的<spanclass="math inline">\(\boldsymbol{\alpha}\)</span>）。而且可以得到，<spanclass="math inline">\(\boldsymbol{P}\)</span>的列向量组中的任意向量要么分别对应了不同的特征值，要么是同一个特征值下的广义特征向量链中的向量。无论是这两种情况中的哪一种，都可以证明它们是线性无关的。关于广义特征向量链的证明参考以下链接：https://zhuanlan.zhihu.com/p/30454490</p><h3 id="再回到母题">再回到母题</h3><p>母题的出题背景此时已经呼之欲出了。再来看答案给出的解题过程，可以看出出题人实际上是把“证明广义特征向量线性无关”这一结论做了特殊化处理，让我们来证明对于一个给定的<spanclass="math inline">\(\text{Jordan}\)</span>型，它的三个广义特征向量是线性无关的。答案给出的解题过程也是完全按照一般结论的证明来进行的：不断对等式两边做<spanclass="math inline">\((\boldsymbol{A}-\lambda\boldsymbol{E})\)</span>的线性变换，直到证明所有的系数均为<spanclass="math inline">\(0\)</span>为止。</p><p>现在我们可以来回答一开始提出的问题了：什么样的<spanclass="math inline">\(\boldsymbol{P}\)</span>才能确保<spanclass="math inline">\(\boldsymbol{\alpha}_{1},\boldsymbol{\alpha}_{2},\boldsymbol{\alpha}_{3}\)</span>线性无关呢？根据上面的知识，作如下推断（只考虑<spanclass="math inline">\(\boldsymbol{P}\)</span>是<spanclass="math inline">\(\text{Jordan}\)</span>标准形的情况）：</p><ol type="1"><li>当<spanclass="math inline">\(\boldsymbol{P}\)</span>属于上述的<strong>第一种、第三种和第四种</strong>标准型时，可以保证<spanclass="math inline">\(\boldsymbol{\alpha}_{1},\boldsymbol{\alpha}_{2},\boldsymbol{\alpha}_{3}\)</span>线性无关。在这种情况下，<spanclass="math inline">\(\boldsymbol{\alpha}_{1},\boldsymbol{\alpha}_{2},\boldsymbol{\alpha}_{3}\)</span>要么是不同特征值对应的特征向量，要么是同一特征向量链下的向量，线性无关。</li><li>当<spanclass="math inline">\(\boldsymbol{P}\)</span>属于上述的<strong>第二种</strong>标准型时，不能保证<spanclass="math inline">\(\boldsymbol{\alpha}_{1},\boldsymbol{\alpha}_{2},\boldsymbol{\alpha}_{3}\)</span>线性无关。如果仍然想要得到结论：需要添加条件<spanclass="math inline">\(\boldsymbol{\alpha}_{2},\boldsymbol{\alpha}_{3}\)</span>是同一特征值下的两个线性无关的向量。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些2023的目标</title>
    <link href="/2023/01/05/2023mubiao/"/>
    <url>/2023/01/05/2023mubiao/</url>
    
    <content type="html"><![CDATA[<h2 id="一些2023的目标">一些2023的目标</h2><p>也许是去年11月到现在这段时间整个社会都太过动荡，思想、舆论极不安定；也可能是由于阳过以后还未敢恢复运动，原本耗散在跑步、骑行和摄影上的精力现在几乎全花在了游思妄想上，最近这些日子总觉得心神不太平静。想做的事情太多、太杂，时间却又太少。</p><p>人似乎总需要一个宣泄口，把头脑中各种杂乱的想法和思绪消解干净。现在每天在家，也不怎么外出，通过运动放空自己是不太可能了，于是建立了博客，想通过这种方式给生活留下一些用来反思和总结的缓冲区。借此机会回顾了一下近日的生活，发现也并非那么混乱不堪，学习和生活大体也还在正轨上运行着，只要再明确几个目标和原则，相信2023也不会太糟。</p><div class="note note-success">            <ol type="1"><li>保持独立思考能力，不要被信息的漩涡吞噬。信息太多，真假难辨，要学会独立思考，不把过多时间浪费在摄入大量网络信息上。</li><li>保持健康的身体。希望开春恢复到良好的运动状态，保有健康的生活习惯。</li><li>每天学点英语。</li><li>做一个学业优秀的学生。这一点无论何时都不能忘，是本职工作。</li><li>希望能把博客坚持写下去。</li></ol>          </div>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第零篇博客</title>
    <link href="/2023/01/05/the-first-blog/"/>
    <url>/2023/01/05/the-first-blog/</url>
    
    <content type="html"><![CDATA[<h2 id="人总会有点木乃伊情结">人总会有点「木乃伊情结」</h2><p>正如古埃及人用防腐香料处理法老的尸体，对抗时间的流逝，使其变成永生的木乃伊，我一直觉得，以介质保存自己的生命是一件十分浪漫的事情。</p><span id="more"></span><p>近几年来学习摄影，不知不觉间拍下了许多照片。曾经有那么一段时间，我以为图片是对“存在”和“经历”最有力的证明，以为通过按动快门、留下影像便可以如实地记录下当时的场景，过上一段时间再回看也一定能重现当时的所感。也许这是对自己文笔粗糙，写出的文字总是佶屈聱牙的逃避，但至少，了解摄影这门艺术，并在技术上有所精进之后，摄影便成为了我保存生命最重要的方式。背上相机、走出校门，朝着感兴趣的东西按下快门，再回到桌前用电脑翻看着拍下的照片，这项活动给我的精神带来了极大的满足和享受。</p><p>再回看自己这两年的QQ空间，也有个很有意思的趋势：本就少得可怜的文字内容变得更少，图片却变得越来越多，越来越精美。甚至有时候发空间想要说点什么，思索推敲了半天，总觉得言辞匮乏、词不达意。想想，算了，干脆发几张最近拍的照片吧。反而是图片似乎还更能反映最近的生活状态，同时还兼具视觉上的美感。</p><div data-align="center"><img src="https://picbed123.oss-cn-beijing.aliyuncs.com/img/IMG_E76A43665E84-1.jpeg" style="zoom:50%;" /></div><div data-align="center"><img src="https://picbed123.oss-cn-beijing.aliyuncs.com/img/IMG_70A8687293B7-1.jpeg" style="zoom:50%;" /></div><p>回家了？那便发张车站的图吧。下了初雪？那便发几张刚拍的雪景吧。最多再发两个“❄️❄️”，作为图片的配角。</p><p>近两年的生活记录几乎都是这样完成的，只有图，文很少，或者没有。有时闲暇时候一大乐事便是插上存着一直以来拍的照片的硬盘，用日期排个序，一张张往下漫无目的地翻，回忆着过去的生活。实在是要感谢摄影，满足了我的「木乃伊情结」。</p><h2 id="一些反思">一些反思</h2><p>“有时只靠图片或许真的不能全面地概括生活，”反复斟酌2022的年终总结配图却又迟迟不能按下确定时，我如是想着。</p><p>诚然，图片能最直白地展示景象。但正由于这种特质，有时候它反而不太能真实地刻画感受。我们摄影时，往往过于关注取景器内的事物在图片的边框内是否是“美”的，而忽视了景物连带环境本身能给我们带来怎样的体验。这种对形式美的追求能造就一幅合格的照片，但却切断了我们的感官与世界本身的链路。有时翻看相册，我会发觉，真正勾起我对往事回忆的，触动我的，并不是那些对着电脑屏幕精修数小时后近乎完美无瑕的“成品图”，而是那些在旅途中、日常生活里的“随手拍”。那些“成品图”就好像空中楼阁，它们是“美”的，但遥不可及，用它们概括我的生活是不适宜的。而那些随手拍，没有刻意的取景和构图，没有考究的调色，但他们如此接近人眼的视角，能在一瞬间唤起某些尘封的记忆，以至于把它们作为生活的实录是再合适不过的。</p><div data-align="center"><img src="https://picbed123.oss-cn-beijing.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2023-01-05%2020.36.31.png" style="zoom:33%;" /></div><div data-align="center"><img src="https://picbed123.oss-cn-beijing.aliyuncs.com/img/%E6%88%AA%E5%B1%8F2023-01-05%2020.37.21.png" style="zoom: 50%;" /></div><p>矛盾在这时出现了。抛开所谓的“艺术摄影”不谈，包括我在内，能为绝大部分人所接受的摄影作品普遍有着唯美的形式，而这一点是随手拍所不具备的。而且出于一般的考虑，很难将在他人看来几乎没有意义的随手拍分享出来，作为可供展示的生活记录。摄影是用来记录现实的手段，可到头来，它对我的意义却又回到了“创作样式精美的图片”，与原本保存生命的目的有所背离。这种矛盾使我感到在社交平台上发布的照片越来越成为了一种“炫技”。我能从大多数人难以察觉的角度用相机捕捉到好看的影像，但我深知这些影像已经不是那个保存我过去生活的「木乃伊」了。</p><h2 id="为什么是博客">为什么是博客</h2><p>用随手拍作为过往生活的存储载体是合格的。它比严肃的摄影更为便捷，触手可及。但缺点同样明显。当你翻看着充满着随手拍的相册时，会发现其形式是杂乱无章的。它们是一个个散落的生活碎片，真实可靠、但完全不成体系。只用随手拍来作为保存生命的介质，总觉得有些不合宜。人啊，终究还是会固执地追求形式上的美感，但“随手拍”显然不太能和“形式美”扯上什么关系。</p><p>有没有某种介质，可以在形式上带来良好的感受，也能具有随手拍真实、广泛的优点呢？我想到了文字博客。</p><p>虽然前文提到了，我并不是一个有好文笔的人。写文章不够快，文字读起来也没什么韵味。但这有什么关系呢？正如随手拍不需要有任何美观的形式便能触动人心，只要用文字把生命中的重要事件记录下来，这便够了。过上数月、数年，当所处的境况变迁、对世界有了新的认知，再回过头来看看之前写下的博文，我猜无论如何都会有所触动的吧。</p><p>当然，这也是目前的一点不成熟的想法和猜测，毕竟一切都才刚刚开始，甚至本站建起来才刚刚两天（笑）。万事开头难，写博客这件事现在最多算是处于pilotrun阶段。但希望它能和摄影一样，成为长久陪伴我的一个习惯，甚至成为生活的一部分吧。</p><h2 id="写些什么">写些什么</h2><p>目前想法是这个博客不做太多推广和引流，权且当作树洞使用，因此可能内容比较杂，涉及到生活的方方面面。但正如刚才所说，写博客的其中一个重要原则是避免“随手拍”式的杂乱记录，因此肯定会做归类和整理。目前预想的tag有：#生活#运动 #技术#学习。之后的写作大部分应该都围绕这几个tag进行并归类。学习的文章是会有的，因为发现Hexo支持<spanclass="math inline">\(\LaTeX\)</span>的渲染，用来写一些学习过程中的思考和收获也是很好的。</p><p>希望自己能坚持下去。</p><p>先到这里吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Test blog</title>
    <link href="/2023/01/04/Blog%20test/"/>
    <url>/2023/01/04/Blog%20test/</url>
    
    <content type="html"><![CDATA[<p>这是我的Testblog，用来测试刚刚完成配置的Hexo是否能够正常推送博文。</p><span id="more"></span><p><span class="math display">\[u(\lambda, T)=\frac{8 \pi h c}{\lambda^5} \cdot \frac{1}{e^{\frac{hc}{\lambda k T}}-1}\]</span> 目前来看，一切正常。</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
